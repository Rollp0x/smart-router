# Smart Order Router 最佳路由选择算法详解

## 1. 概述

`getBestSwapRoute` 和 `getBestSwapRouteBy` 函数实现了 Smart Order Router 的核心路由优化算法。该算法通过广度优先搜索（BFS）来寻找最优的路由组合，支持路由拆分以获得更好的交易价格。

## 2. 算法核心思想

### 2.1 路由拆分原理
算法的核心思想是将大额交易拆分为多个小额交易，通过不同的路由路径执行，以获得更好的整体价格。例如：
- 一笔 1000 USDT → ETH 的交易可能拆分为：
  - 60% 通过 Uniswap V3 的 USDT/ETH 0.05% 池
  - 30% 通过 Uniswap V2 的 USDT/ETH 池
  - 10% 通过 Uniswap V4 的 USDT/WETH 池

### 2.2 优化目标
算法优化的是调整后的报价（Gas 成本调整后）：
```javascript
const swapRoute = await getBestSwapRouteBy(
  routeType, percentToQuotes, percents, chainId,
  (rq) => rq.quoteAdjustedForGas,  // 优化目标：Gas 调整后的报价
  // ... other parameters
);
```

## 3. 算法详细流程

### 3.1 数据结构初始化

#### 百分比到报价映射
```javascript
const percentToQuotes = {};
for (const routeWithValidQuote of routesWithValidQuotes) {
  if (!percentToQuotes[routeWithValidQuote.percent]) {
    percentToQuotes[routeWithValidQuote.percent] = [];
  }
  percentToQuotes[routeWithValidQuote.percent].push(routeWithValidQuote);
}
```

#### 报价排序
```javascript
const percentToSortedQuotes = lodash.mapValues(percentToQuotes, (routeQuotes) => {
  return routeQuotes.sort((routeQuoteA, routeQuoteB) => {
    if (routeType == TradeType.EXACT_INPUT) {
      return by(routeQuoteA).greaterThan(by(routeQuoteB)) ? -1 : 1;
    } else {
      return by(routeQuoteA).lessThan(by(routeQuoteB)) ? -1 : 1;
    }
  });
});
```

### 3.2 最优堆管理
使用固定大小的反向堆来追踪最佳路由组合：
```javascript
const bestSwapsPerSplit = new FixedReverseHeap(Array, (a, b) => {
  return quoteCompFn(a.quote, b.quote) ? -1 : 1;
}, 3);  // 只保留前 3 个最佳组合
```

### 3.3 广度优先搜索（BFS）算法

#### 初始化队列
```javascript
const queue = new Queue();

// 用每个百分比的最佳报价作为 BFS 的起始点
for (let i = percents.length; i >= 0; i--) {
  const percent = percents[i];
  if (!percentToSortedQuotes[percent]) continue;
  
  // 添加最佳报价
  queue.enqueue({
    curRoutes: [percentToSortedQuotes[percent][0]],
    percentIndex: i,
    remainingPercent: 100 - percent,
    special: false,
  });
  
  // 添加次佳报价（如果存在）
  if (percentToSortedQuotes[percent][1]) {
    queue.enqueue({
      curRoutes: [percentToSortedQuotes[percent][1]],
      percentIndex: i,
      remainingPercent: 100 - percent,
      special: true,
    });
  }
}
```

#### BFS 主循环
```javascript
let splits = 1;
while (queue.size > 0) {
  let layer = queue.size;
  splits++;
  
  // 检查终止条件
  if (splits >= 3 && bestSwap && bestSwap.length < splits - 1) {
    break;  // 如果增加拆分没有改善报价，停止搜索
  }
  
  if (splits > maxSplits) {
    break;  // 达到最大拆分数
  }
  
  while (layer > 0) {
    layer--;
    const { remainingPercent, curRoutes, percentIndex, special } = queue.dequeue();
    
    // 为剩余百分比尝试所有可能的路由
    for (let i = percentIndex; i >= 0; i--) {
      const percentA = percents[i];
      if (percentA > remainingPercent) continue;
      
      if (!percentToSortedQuotes[percentA]) continue;
      
      const candidateRoutesA = percentToSortedQuotes[percentA];
      
      // 找到不重复使用已用池子的最佳路由
      const routeWithQuoteA = findFirstRouteNotUsingUsedPools(
        curRoutes, candidateRoutesA, forceCrossProtocol
      );
      
      if (!routeWithQuoteA) continue;
      
      const remainingPercentNew = remainingPercent - percentA;
      const curRoutesNew = [...curRoutes, routeWithQuoteA];
      
      // 如果找到了使用全部 100% 的路由组合
      if (remainingPercentNew == 0 && splits >= minSplits) {
        const quotesNew = lodash.map(curRoutesNew, (r) => by(r));
        const quoteNew = sumFn(quotesNew);
        
        // 计算 L1 Gas 费用（对于 L2 网络）
        let gasCostL1QuoteToken = CurrencyAmount.fromRawAmount(quoteNew.currency, 0);
        if (HAS_L1_FEE.includes(chainId)) {
          // 分别计算各协议的 L1 Gas 费用
          const v2Routes = curRoutesNew.filter(r => r.protocol === Protocol.V2);
          const v3Routes = curRoutesNew.filter(r => r.protocol === Protocol.V3);
          const v4Routes = curRoutesNew.filter(r => r.protocol === Protocol.V4);
          
          if (v2Routes.length > 0 && v2GasModel) {
            const v2GasCostL1 = await v2GasModel.calculateL1GasFees(v2Routes);
            gasCostL1QuoteToken = gasCostL1QuoteToken.add(v2GasCostL1.gasCostL1QuoteToken);
          }
          // ... V3 和 V4 的类似处理
        }
        
        // 调整报价以考虑 L1 Gas 费用
        const quoteAfterL1Adjust = routeType == TradeType.EXACT_INPUT
          ? quoteNew.subtract(gasCostL1QuoteToken)
          : quoteNew.add(gasCostL1QuoteToken);
        
        // 更新最佳路由
        bestSwapsPerSplit.push({
          quote: quoteAfterL1Adjust,
          routes: curRoutesNew,
        });
        
        if (!bestQuote || quoteCompFn(quoteAfterL1Adjust, bestQuote)) {
          bestQuote = quoteAfterL1Adjust;
          bestSwap = curRoutesNew;
        }
      } else if (remainingPercentNew > 0) {
        // 继续搜索更多拆分
        queue.enqueue({
          curRoutes: curRoutesNew,
          percentIndex: i,
          remainingPercent: remainingPercentNew,
          special,
        });
      }
    }
  }
}
```

### 3.4 池子重用检测
```javascript
function findFirstRouteNotUsingUsedPools(
  usedRoutes: RouteWithValidQuote[],
  candidateRoutesWithQuotes: RouteWithValidQuote[],
  forceCrossProtocol: boolean
): RouteWithValidQuote | null {
  const poolAddressSet = new Set();
  const protocolSet = new Set();
  
  // 收集已使用的池子地址和协议
  for (const usedRoute of usedRoutes) {
    const { pools, protocol } = usedRoute.route;
    for (const pool of pools) {
      poolAddressSet.add(poolId(pool));
    }
    protocolSet.add(protocol);
  }
  
  // 查找不重复使用池子的候选路由
  for (const routeWithQuote of candidateRoutesWithQuotes) {
    const { route, protocol } = routeWithQuote;
    
    // 如果强制跨协议，检查协议是否重复
    if (forceCrossProtocol && protocolSet.has(protocol)) {
      continue;
    }
    
    let poolUsed = false;
    for (const pool of route.pools) {
      if (poolAddressSet.has(poolId(pool))) {
        poolUsed = true;
        break;
      }
    }
    
    if (!poolUsed) {
      return routeWithQuote;
    }
  }
  
  return null;
}
```

## 4. 算法优化特性

### 4.1 早期终止策略
- **拆分效率检查**: 如果增加拆分数量没有改善报价，提前终止
- **最大拆分限制**: 防止过度拆分导致 Gas 费用过高
- **最小拆分要求**: 确保满足最小拆分数量要求

### 4.2 Gas 费用优化
- **L2 网络支持**: 特别处理 L1 Gas 费用（如 Arbitrum、Optimism）
- **协议分离计算**: 分别计算各协议的 Gas 费用
- **动态调整**: 根据 Gas 费用调整最终报价

### 4.3 池子流动性保护
- **避免重复使用**: 防止在同一个池子中多次交易
- **流动性准确性**: 确保报价反映真实的流动性状态

### 4.4 跨协议优化
- **强制跨协议**: 可选择强制使用不同协议的组合
- **协议多样性**: 通过多协议组合获得更好的价格

## 5. 性能指标和监控

### 5.1 拆分层级监控
```javascript
metric.putMetric(`Split${splits}Done`, Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);
metric.putMetric(`Split${splits}Done_Chain${chainId}`, Date.now() - startedSplit, MetricLoggerUnit.Milliseconds);
```

### 5.2 搜索空间监控
```javascript
log.info({
  top5: lodash.map(Array.from(bestSwapsPerSplit.consume()), (q) => 
    `${q.quote.toExact()} (${q.routes.map(r => r.toString()).join(', ')})`),
  onQueue: queue.size,
}, `Top 3 with ${splits} splits`);
```

## 6. 结果处理和精度调整

### 6.1 金额精度修正
```javascript
const totalAmount = lodash.reduce(routeAmounts, 
  (total, routeAmount) => total.add(routeAmount.amount),
  CurrencyAmount.fromRawAmount(routeAmounts[0].amount.currency, 0)
);

const missingAmount = amount.subtract(totalAmount);
if (missingAmount.greaterThan(0)) {
  // 将缺失的金额添加到最后一个路由
  routeAmounts[routeAmounts.length - 1].amount = 
    routeAmounts[routeAmounts.length - 1].amount.add(missingAmount);
}
```

### 6.2 结果输出
```javascript
log.info({
  routes: routeAmountsToString(routeAmounts),
  numSplits: routeAmounts.length,
  amount: amount.toExact(),
  quote: swapRoute.quote.toExact(),
  quoteGasAdjusted: swapRoute.quoteGasAdjusted.toFixed(2),
  estimatedGasUSD: swapRoute.estimatedGasUsedUSD.toFixed(2),
  estimatedGasToken: swapRoute.estimatedGasUsedQuoteToken.toFixed(2),
}, `Found best swap route. ${routeAmounts.length} split.`);
```

## 7. 自定义聚合器开发建议

### 7.1 算法核心理解
1. **BFS 搜索**: 理解如何通过 BFS 探索所有可能的路由组合
2. **拆分优化**: 掌握如何平衡拆分数量和 Gas 费用
3. **池子管理**: 确保避免池子重复使用以保证报价准确性

### 7.2 性能优化要点
1. **搜索空间控制**: 合理设置最大拆分数量和搜索深度
2. **早期终止**: 实现有效的早期终止条件
3. **内存管理**: 使用固定大小的堆来控制内存使用

### 7.3 扩展机会
1. **自定义评分函数**: 可以替换 `by` 函数来使用不同的优化目标
2. **协议权重**: 为不同协议设置权重以引导搜索方向
3. **动态参数**: 根据市场条件动态调整搜索参数

这个算法为构建高效的聚合器提供了强大的基础，通过理解其核心原理可以开发出适合特定需求的自定义路由算法。
