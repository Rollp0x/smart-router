# Smart Order Router æºç æ·±åº¦åˆ†æ

## æ¦‚è¿°

`@uniswap/smart-order-router` æ˜¯ Uniswap èšåˆå™¨çš„æ ¸å¿ƒç®—æ³•åº“ï¼ŒåŒ…å«äº†æ™ºèƒ½è·¯ç”±ã€ä»·æ ¼å‘ç°ã€Gasä¼˜åŒ–ç­‰æ ¸å¿ƒåŠŸèƒ½ã€‚é€šè¿‡æ·±å…¥åˆ†æå…¶æºç ï¼Œæˆ‘ä»¬å¯ä»¥å­¦ä¹ åˆ°ï¼š

1. **è·¯ç”±ç®—æ³•çš„å…·ä½“å®ç°**
2. **å¤šåè®®æ± æ•°æ®è·å–ä¸ç®¡ç†**
3. **Gasè´¹ç”¨ä¼°ç®—å’Œä¼˜åŒ–ç­–ç•¥**
4. **ç¼“å­˜æœºåˆ¶çš„è®¾è®¡æ¨¡å¼**
5. **é“¾ä¸Šæ•°æ®åŒæ­¥ä¸å¤„ç†**

## æ ¸å¿ƒæ¶æ„

### ğŸ§  AlphaRouter - ä¸»è·¯ç”±å¼•æ“

AlphaRouter æ˜¯æ•´ä¸ªç³»ç»Ÿçš„æ ¸å¿ƒï¼Œåè°ƒå„ä¸ªå­æ¨¡å—å·¥ä½œï¼š

```typescript
// ä» alpha-router.d.ts åˆ†æå¾—å‡ºçš„æ ¸å¿ƒç»“æ„
export declare class AlphaRouter implements IRouter<AlphaRouterConfig> {
  
  constructor(params: AlphaRouterParams);
  
  // æ ¸å¿ƒè·¯ç”±æ–¹æ³•
  route(
    amount: CurrencyAmount,
    quoteCurrency: Currency, 
    tradeType: TradeType,
    swapConfig?: SwapOptions,
    partialRoutingConfig?: Partial<AlphaRouterConfig>
  ): Promise<SwapRoute | null>;
  
  // æµåŠ¨æ€§æ¯”ä¾‹è·¯ç”±
  routeToRatio(
    token0Balance: CurrencyAmount,
    token1Balance: CurrencyAmount,
    position: Position,
    swapAndAddConfig: SwapAndAddConfig,
    swapAndAddOptions?: SwapAndAddOptions,
    routingConfig?: Partial<AlphaRouterConfig>
  ): Promise<SwapToRatioResponse>;
}
```

### ğŸ”§ æ ¸å¿ƒç»„ä»¶ä¾èµ–

```mermaid
graph TB
    subgraph "AlphaRouter æ ¸å¿ƒ"
        AR[AlphaRouter]
        Config[AlphaRouterConfig]
    end
    
    subgraph "æ•°æ®æä¾›å•†"
        V2PP[V2PoolProvider]
        V3PP[V3PoolProvider] 
        V4PP[V4PoolProvider]
        V2SP[V2SubgraphProvider]
        V3SP[V3SubgraphProvider]
        V4SP[V4SubgraphProvider]
        TP[TokenProvider]
        GP[GasPriceProvider]
    end
    
    subgraph "æŠ¥ä»·å™¨"
        V2Q[V2Quoter]
        V3Q[V3Quoter]
        V4Q[V4Quoter]
        MQ[MixedQuoter]
        OCQ[OnChainQuoteProvider]
    end
    
    subgraph "Gasæ¨¡å‹"
        V2GM[V2GasModel]
        V3GM[V3GasModel]
        V4GM[V4GasModel]
        MGM[MixedGasModel]
    end
    
    subgraph "ç¼“å­˜ç³»ç»Ÿ"
        RC[RouteCachingProvider]
        PC[PoolCachingProvider]
        TC[TokenCachingProvider]
    end
    
    AR --> V2PP
    AR --> V3PP
    AR --> V4PP
    AR --> V2Q
    AR --> V3Q
    AR --> V4Q
    AR --> MQ
    AR --> RC
    
    V2Q --> OCQ
    V3Q --> OCQ
    V4Q --> OCQ
    
    V2PP --> V2SP
    V3PP --> V3SP
    V4PP --> V4SP
    
    V2Q --> V2GM
    V3Q --> V3GM
    V4Q --> V4GM
    MQ --> MGM
    
    AR --> PC
    AR --> TC
```

## è·¯ç”±ç®—æ³•æ ¸å¿ƒ

### ğŸ¯ è·¯ç”±é€‰æ‹©ç­–ç•¥

```typescript
// æ ¹æ® alpha-router.d.ts åˆ†æçš„æ± é€‰æ‹©é…ç½®
export declare type ProtocolPoolSelection = {
  // æŒ‰TVLæ’åºçš„å‰Nä¸ªæ± å­
  topN: number;
  
  // tokenIn-tokenOut ç›´æ¥äº¤æ˜“å¯¹çš„å‰Nä¸ªæ± å­
  topNDirectSwaps: number;
  
  // åŒ…å« tokenIn æˆ– tokenOut çš„å‰Nä¸ªæ± å­
  topNTokenInOut: number;
  
  // äºŒè·³è·¯ç”±çš„æ± å­æ•°é‡
  topNSecondHop: number;
  
  // ä¸æŒ‡å®šåŸºç¡€ä»£å¸é…å¯¹çš„æ± å­æ•°é‡
  topNWithEachBaseToken: number;
  topNWithBaseToken: number;
};

// å®Œæ•´çš„è·¯ç”±é…ç½®
export declare type AlphaRouterConfig = {
  // V2ã€V3ã€V4 åè®®çš„æ± é€‰æ‹©é…ç½®
  v2PoolSelection: ProtocolPoolSelection;
  v3PoolSelection: ProtocolPoolSelection;
  v4PoolSelection: ProtocolPoolSelection;
  
  // è·¯å¾„æœç´¢é…ç½®
  maxSwapsPerPath: number;      // æ¯æ¡è·¯å¾„æœ€å¤§è·³æ•°
  minSplits: number;            // æœ€å°è·¯å¾„æ‹†åˆ†æ•°
  maxSplits: number;            // æœ€å¤§è·¯å¾„æ‹†åˆ†æ•°
  distributionPercent: number;  // åˆ†é…ç™¾åˆ†æ¯”
  
  // åè®®ç»„åˆç­–ç•¥
  forceCrossProtocol: boolean;  // å¼ºåˆ¶è·¨åè®®è·¯ç”±
  
  // ç¼“å­˜é…ç½®
  cacheMode?: CacheMode;
  writeToCachedRoutes?: boolean;
  
  // æ„å›¾é©±åŠ¨é…ç½®
  intent?: INTENT;
};
```

### ğŸ“Š è·¯ç”±è¯„åˆ†æœºåˆ¶

ä»æºç ç»“æ„å¯ä»¥æ¨æ–­è·¯ç”±è¯„åˆ†è€ƒè™‘ä»¥ä¸‹å› ç´ ï¼š

```typescript
// è·¯ç”±è¯„åˆ†è¦ç´ 
interface RouteEvaluation {
  // è¾“å‡ºé‡‘é¢ï¼ˆè¶Šå¤§è¶Šå¥½ï¼‰
  outputAmount: CurrencyAmount;
  
  // Gasè´¹ç”¨ï¼ˆè¶Šå°è¶Šå¥½ï¼‰
  gasEstimate: CurrencyAmount;
  
  // ä»·æ ¼å½±å“ï¼ˆè¶Šå°è¶Šå¥½ï¼‰
  priceImpact: number;
  
  // æµåŠ¨æ€§æ·±åº¦
  liquidityDepth: number;
  
  // è·¯å¾„å¤æ‚åº¦æƒ©ç½š
  pathComplexityPenalty: number;
  
  // åè®®å¯é æ€§æƒé‡
  protocolReliabilityWeight: number;
}

// ç»¼åˆè¯„åˆ†è®¡ç®—
function calculateRouteScore(route: RouteEvaluation): number {
  const outputScore = route.outputAmount.toNumber();
  const gasPenalty = route.gasEstimate.toNumber();
  const impactPenalty = route.priceImpact * IMPACT_PENALTY_FACTOR;
  const complexityPenalty = route.pathComplexityPenalty;
  
  return (outputScore * route.protocolReliabilityWeight) 
         - gasPenalty 
         - impactPenalty 
         - complexityPenalty;
}
```

## æ•°æ®æä¾›å•†ç³»ç»Ÿ

### ğŸŠâ€â™‚ï¸ æ± æ•°æ®æä¾›å•†

#### V3PoolProvider
```typescript
// V3 æ± æ•°æ®è·å–æ¥å£
export interface IV3PoolProvider {
  getPools(
    tokenPairs: [Token, Token][],
    providerConfig?: ProviderConfig
  ): Promise<V3PoolAccessor>;
  
  getPoolAddress(
    tokenA: Token,
    tokenB: Token,
    feeAmount: FeeAmount
  ): { poolAddress: string; token0: Token; token1: Token };
}

// æ”¯æŒçš„è´¹ç‡æ¡£ä½
enum FeeAmount {
  LOWEST = 100,     // 0.01%
  LOW = 500,        // 0.05% 
  MEDIUM = 3000,    // 0.3%
  HIGH = 10000,     // 1%
}
```

#### V4PoolProvider
```typescript
// V4 æ± æ•°æ®ï¼ˆæ”¯æŒé’©å­ï¼‰
export interface IV4PoolProvider {
  getPools(
    tokenPairs: [Token, Token][],
    providerConfig?: ProviderConfig
  ): Promise<V4PoolAccessor>;
  
  // V4 ç‰¹æœ‰çš„é’©å­æ”¯æŒ
  getPoolsWithHooks(
    tokenPairs: [Token, Token][],
    hooksOptions: HooksOptions,
    providerConfig?: ProviderConfig
  ): Promise<V4PoolAccessor>;
}

// é’©å­é…ç½®é€‰é¡¹
export interface HooksOptions {
  beforeSwap?: boolean;
  afterSwap?: boolean;
  beforeAddLiquidity?: boolean;
  afterAddLiquidity?: boolean;
  beforeRemoveLiquidity?: boolean;
  afterRemoveLiquidity?: boolean;
  beforeDonate?: boolean;
  afterDonate?: boolean;
}
```

### ğŸ“ˆ Subgraph æ•°æ®åŒæ­¥

```typescript
// Subgraph æ•°æ®æä¾›å•†æ¥å£
export interface ISubgraphProvider<TSubgraphPool> {
  getPools(
    tokenIn?: Token,
    tokenOut?: Token,
    providerConfig?: ProviderConfig
  ): Promise<TSubgraphPool[]>;
}

// V3 Subgraph æ± æ•°æ®
export interface V3SubgraphPool {
  id: string;
  token0: Token;
  token1: Token;
  feeTier: string;
  liquidity: string;
  sqrtPrice: string;
  tick: string;
  tvlETH: number;
  tvlUSD: number;
}

// å¸¦å›é€€çš„ Subgraph æä¾›å•†
export class SubgraphProviderWithFallback<TSubgraphPool> implements ISubgraphProvider<TSubgraphPool> {
  constructor(
    private fallbacks: ISubgraphProvider<TSubgraphPool>[]
  ) {}
  
  async getPools(
    tokenIn?: Token,
    tokenOut?: Token,
    providerConfig?: ProviderConfig
  ): Promise<TSubgraphPool[]> {
    for (const provider of this.fallbacks) {
      try {
        return await provider.getPools(tokenIn, tokenOut, providerConfig);
      } catch (error) {
        // è®°å½•é”™è¯¯ï¼Œå°è¯•ä¸‹ä¸€ä¸ªæä¾›å•†
        log.warn({ error }, 'Subgraph provider failed, trying next fallback');
        continue;
      }
    }
    throw new Error('All subgraph providers failed');
  }
}
```

## é“¾ä¸ŠæŠ¥ä»·ç³»ç»Ÿ

### ğŸ’° OnChainQuoteProvider

```typescript
// é“¾ä¸ŠæŠ¥ä»·æä¾›å•†
export interface IOnChainQuoteProvider {
  getQuotesManyExactIn(
    amountIns: CurrencyAmount[],
    routes: Route[]
  ): Promise<{
    blockNumber: BigNumber;
    results: Array<{
      success: boolean;
      quotedAmount?: CurrencyAmount;
      gasEstimate?: BigNumber;
    }>;
  }>;
  
  getQuotesManyExactOut(
    amountOuts: CurrencyAmount[],
    routes: Route[]
  ): Promise<{
    blockNumber: BigNumber;
    results: Array<{
      success: boolean;
      quotedAmount?: CurrencyAmount;
      gasEstimate?: BigNumber;
    }>;
  }>;
}

// æ‰¹é‡æŠ¥ä»·ä¼˜åŒ–
export class OnChainQuoteProvider implements IOnChainQuoteProvider {
  constructor(
    private chainId: ChainId,
    private provider: BaseProvider,
    private multicallProvider: UniswapMulticallProvider,
    private retryOptions?: RetryOptions,
    private batchParams?: {
      multicallChunk: number;      // æ¯æ¬¡multicallçš„è°ƒç”¨æ•°é‡
      gasLimitPerCall: number;     // æ¯æ¬¡è°ƒç”¨çš„Gasé™åˆ¶
      quoteMinSuccessRate: number; // æœ€å°æˆåŠŸç‡
    }
  ) {}
}
```

### âš¡ æŠ¥ä»·å™¨ (Quoters)

```typescript
// V3 æŠ¥ä»·å™¨
export class V3Quoter {
  constructor(
    private v3PoolProvider: IV3PoolProvider,
    private onChainQuoteProvider: IOnChainQuoteProvider,
    private tokenProvider: ITokenProvider
  ) {}
  
  async getRoutesThenQuotes(
    tokenIn: Token,
    tokenOut: Token,
    amount: CurrencyAmount,
    percents: number[],
    quoteToken: Token,
    v3GasModel: IG3GasModelFactory,
    swapConfig: SwapOptions,
    routingConfig: AlphaRouterConfig
  ): Promise<{
    routesWithValidQuotes: V3RouteWithValidQuote[];
    candidatePools: V3Pool[];
  }>;
}

// æ··åˆæŠ¥ä»·å™¨ï¼ˆè·¨åè®®ï¼‰
export class MixedQuoter {
  constructor(
    private v2PoolProvider: IV2PoolProvider,
    private v3PoolProvider: IV3PoolProvider,
    private v4PoolProvider: IV4PoolProvider,
    private onChainQuoteProvider: IOnChainQuoteProvider
  ) {}
  
  async getRoutesThenQuotes(
    tokenIn: Token,
    tokenOut: Token,
    amount: CurrencyAmount,
    percents: number[],
    quoteToken: Token,
    gasModels: {
      v2GasModel: IV2GasModelFactory;
      v3GasModel: IG3GasModelFactory;
      v4GasModel: IG4GasModelFactory;
      mixedGasModel: IMixedGasModelFactory;
    },
    swapConfig: SwapOptions,
    routingConfig: AlphaRouterConfig
  ): Promise<{
    routesWithValidQuotes: MixedRouteWithValidQuote[];
    candidatePools: Array<V2Pool | V3Pool | V4Pool>;
  }>;
}
```

## Gasè´¹ç”¨å»ºæ¨¡

### â›½ Gasæ¨¡å‹å·¥å‚

```typescript
// Gasæ¨¡å‹æ¥å£
export interface IOnChainGasModelFactory<T extends RouteWithValidQuote> {
  buildGasModel(
    chainId: ChainId,
    gasPriceWei: BigNumber,
    poolProvider: IPoolProvider,
    token: Token,
    l2GasDataProvider?: IL2GasDataProvider,
    providerConfig?: ProviderConfig
  ): Promise<IOnChainGasModel<T>>;
}

// Gasè´¹ç”¨ä¼°ç®—
export interface IOnChainGasModel<T extends RouteWithValidQuote> {
  estimateGasCost(route: T): {
    gasEstimate: BigNumber;
    gasCostInToken: CurrencyAmount;
    gasCostInUSD: CurrencyAmount;
  };
}

// V3 ç‰¹å®šçš„Gasæ¨¡å‹
export class V3HeuristicGasModelFactory implements IOnChainGasModelFactory<V3RouteWithValidQuote> {
  async buildGasModel(
    chainId: ChainId,
    gasPriceWei: BigNumber,
    poolProvider: IV3PoolProvider,
    token: Token
  ): Promise<IV3GasModel> {
    // åŸºç¡€Gasæ¶ˆè€—
    const BASE_SWAP_COST = BigNumber.from(135000);
    
    // Tick crossing æˆæœ¬
    const COST_PER_INIT_TICK = BigNumber.from(31000);
    const COST_PER_HOP = BigNumber.from(80000);
    
    return new V3HeuristicGasModel(
      gasPriceWei,
      BASE_SWAP_COST,
      COST_PER_INIT_TICK,
      COST_PER_HOP,
      token
    );
  }
}
```

## ç¼“å­˜æœºåˆ¶

### ğŸ—‚ï¸ è·¯ç”±ç¼“å­˜

```typescript
// è·¯ç”±ç¼“å­˜æ¥å£
export interface IRouteCachingProvider {
  getCachedRoute(
    chainId: ChainId,
    amount: CurrencyAmount,
    quoteToken: Token,
    tradeType: TradeType,
    protocols: Protocol[],
    blockNumber: number,
    optimistic: boolean
  ): Promise<CachedRoutes | undefined>;
  
  setCachedRoute(
    cachedRoutes: CachedRoutes,
    amount: CurrencyAmount
  ): Promise<boolean>;
}

// ç¼“å­˜çš„è·¯ç”±æ•°æ®
export class CachedRoutes {
  constructor(
    public routes: CachedRoute[],
    public chainId: ChainId,
    public currencyIn: Currency,
    public currencyOut: Currency,
    public protocolsCovered: Protocol[],
    public blockNumber: number,
    public tradeType: TradeType,
    public originalAmount: string,
    public blocksToLive: number
  ) {}
}

// å•ä¸ªç¼“å­˜è·¯ç”±
export class CachedRoute {
  constructor(
    public route: Route,
    public percent: number
  ) {}
}
```

### ğŸ’¾ æ± ç¼“å­˜æä¾›å•†

```typescript
// V3 æ± ç¼“å­˜
export class CachingV3PoolProvider implements IV3PoolProvider {
  constructor(
    private poolProvider: IV3PoolProvider,
    private cache: ICache<V3Pool[]>,
    private cacheKey: (tokenA: Token, tokenB: Token, feeAmount: FeeAmount) => string
  ) {}
  
  async getPools(
    tokenPairs: [Token, Token][],
    providerConfig?: ProviderConfig
  ): Promise<V3PoolAccessor> {
    const cachedPools = new Map<string, V3Pool>();
    const missingPairs: [Token, Token][] = [];
    
    // æ£€æŸ¥ç¼“å­˜
    for (const [tokenA, tokenB] of tokenPairs) {
      for (const feeAmount of FEE_AMOUNTS) {
        const cacheKey = this.cacheKey(tokenA, tokenB, feeAmount);
        const cachedPool = await this.cache.get(cacheKey);
        
        if (cachedPool) {
          cachedPools.set(cacheKey, cachedPool);
        } else {
          missingPairs.push([tokenA, tokenB]);
        }
      }
    }
    
    // è·å–ç¼ºå¤±çš„æ± æ•°æ®
    if (missingPairs.length > 0) {
      const freshPools = await this.poolProvider.getPools(missingPairs, providerConfig);
      
      // æ›´æ–°ç¼“å­˜
      for (const [key, pool] of freshPools.getAllPools()) {
        await this.cache.set(key, pool, POOL_CACHE_TTL);
        cachedPools.set(key, pool);
      }
    }
    
    return new V3PoolAccessor(cachedPools);
  }
}
```

## æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### ğŸš€ å¹¶å‘å¤„ç†

```typescript
// å¹¶å‘è·å–è·¯ç”±æŠ¥ä»·
export class ConcurrentQuoteProcessor {
  async processQuotes(
    routes: Route[],
    amounts: CurrencyAmount[],
    concurrency: number = 10
  ): Promise<QuoteResult[]> {
    const chunks = this.chunkArray(routes, concurrency);
    const results: QuoteResult[] = [];
    
    for (const chunk of chunks) {
      const chunkPromises = chunk.map(route => 
        this.getQuoteForRoute(route, amounts)
      );
      
      const chunkResults = await Promise.allSettled(chunkPromises);
      
      chunkResults.forEach((result, index) => {
        if (result.status === 'fulfilled') {
          results.push(result.value);
        } else {
          log.warn({ 
            route: chunk[index], 
            error: result.reason 
          }, 'Quote failed for route');
        }
      });
    }
    
    return results;
  }
  
  private chunkArray<T>(array: T[], chunkSize: number): T[][] {
    const chunks: T[][] = [];
    for (let i = 0; i < array.length; i += chunkSize) {
      chunks.push(array.slice(i, i + chunkSize));
    }
    return chunks;
  }
}
```

### âš¡ é‡è¯•æœºåˆ¶

```typescript
// æ™ºèƒ½é‡è¯•ç­–ç•¥
export class RetryProvider<T> {
  constructor(
    private provider: () => Promise<T>,
    private retryOptions: {
      retries: number;
      minTimeout: number;
      maxTimeout: number;
      randomize: boolean;
      onRetry?: (error: Error, attempt: number) => void;
    }
  ) {}
  
  async execute(): Promise<T> {
    let lastError: Error;
    
    for (let attempt = 0; attempt <= this.retryOptions.retries; attempt++) {
      try {
        return await this.provider();
      } catch (error) {
        lastError = error as Error;
        
        if (attempt === this.retryOptions.retries) {
          throw lastError;
        }
        
        // æŒ‡æ•°é€€é¿
        const timeout = Math.min(
          this.retryOptions.minTimeout * Math.pow(2, attempt),
          this.retryOptions.maxTimeout
        );
        
        const jitteredTimeout = this.retryOptions.randomize
          ? timeout * (0.5 + Math.random() * 0.5)
          : timeout;
        
        this.retryOptions.onRetry?.(lastError, attempt + 1);
        await this.delay(jitteredTimeout);
      }
    }
    
    throw lastError!;
  }
  
  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

## å­¦ä¹ è¦ç‚¹æ€»ç»“

### ğŸ¯ å…³é”®è®¾è®¡æ¨¡å¼

1. **æä¾›å•†æ¨¡å¼**: æ‰€æœ‰æ•°æ®è·å–éƒ½é€šè¿‡æä¾›å•†æ¥å£ï¼Œæ”¯æŒä¸åŒå®ç°å’Œç¼“å­˜
2. **å·¥å‚æ¨¡å¼**: Gasæ¨¡å‹ã€æŠ¥ä»·å™¨ç­‰éƒ½ä½¿ç”¨å·¥å‚æ¨¡å¼åˆ›å»º
3. **ç­–ç•¥æ¨¡å¼**: ä¸åŒåè®®æœ‰ä¸åŒçš„è·¯ç”±ç­–ç•¥å’ŒGasæ¨¡å‹
4. **è§‚å¯Ÿè€…æ¨¡å¼**: é€šè¿‡å›è°ƒå’Œäº‹ä»¶å¤„ç†å¼‚æ­¥æ“ä½œ
5. **è£…é¥°å™¨æ¨¡å¼**: ç¼“å­˜ã€é‡è¯•ç­‰åŠŸèƒ½é€šè¿‡è£…é¥°å™¨æ¨¡å¼æ·»åŠ 

### ğŸ”§ æ ¸å¿ƒæŠ€æœ¯è¦ç‚¹

1. **å¤šåè®®èšåˆ**: ç»Ÿä¸€æŠ½è±¡ä¸åŒAMMåè®®çš„å·®å¼‚
2. **æ™ºèƒ½è·¯å¾„æœç´¢**: åŸºäºå›¾ç®—æ³•çš„æœ€ä¼˜è·¯å¾„å‘ç°
3. **Gasè´¹ç”¨ä¼˜åŒ–**: ç²¾ç¡®çš„Gasæ¨¡å‹å’Œæˆæœ¬ä¼°ç®—
4. **å¹¶å‘å¤„ç†**: é«˜æ•ˆçš„æ‰¹é‡æ“ä½œå’Œå¹¶å‘æ§åˆ¶
5. **é”™è¯¯æ¢å¤**: å®Œå–„çš„é‡è¯•å’Œé™çº§æœºåˆ¶

### ğŸ“š è¿›ä¸€æ­¥å­¦ä¹ æ–¹å‘

1. **æ·±å…¥ç‰¹å®šåè®®**: è¯¦ç»†å­¦ä¹ V2ã€V3ã€V4çš„å…·ä½“å®ç°å·®å¼‚
2. **Gasä¼˜åŒ–æŠ€å·§**: ç ”ç©¶ä¸åŒé“¾ä¸Šçš„Gasä¼˜åŒ–ç­–ç•¥
3. **ç¼“å­˜è®¾è®¡**: å­¦ä¹ å¤šå±‚ç¼“å­˜å’Œå¤±æ•ˆç­–ç•¥
4. **æ€§èƒ½è°ƒä¼˜**: å¹¶å‘æ§åˆ¶ã€å†…å­˜ç®¡ç†ã€ç½‘ç»œä¼˜åŒ–
5. **é”™è¯¯å¤„ç†**: å¼‚å¸¸å¤„ç†å’Œç³»ç»Ÿç¨³å®šæ€§è®¾è®¡

---

**ä¸‹ä¸€èŠ‚**: [è·¯ç”±ç®—æ³•å…·ä½“å®ç°åˆ†æ](./02-è·¯ç”±ç®—æ³•å…·ä½“å®ç°åˆ†æ.md)
